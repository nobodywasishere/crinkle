# Phase 22a â€” Schema-Aware Linting

## Objectives
- Load schema from Phase 22 and validate template usage.
- Provide signature-aware lint rules for filters/tests/functions/callables.
- Catch errors at lint time that would otherwise fail at runtime.

## Priority
**MEDIUM** - Immediate value from Phase 22 schema

## Motivation

With the schema from Phase 22, the linter can validate template code against known signatures:

```jinja
{{ price | money_format(curreny="EUR") }}
{# LINT ERROR: Unknown kwarg 'curreny'. Did you mean 'currency'? #}

{{ price | money_format("USD", "EUR") }}
{# LINT ERROR: money_format takes 1 positional arg, got 2 #}

{{ user | money_format }}
{# LINT WARNING: money_format expects Number, got User #}
```

## Schema Loading

The linter loads `.crinkle/schema.json` (generated by Phase 22):

```crystal
class Crinkle::Linter
  def initialize(schema_path : String? = nil)
    @schema = if schema_path && File.exists?(schema_path)
      Schema.from_json(File.read(schema_path))
    else
      Schema.empty  # Built-in Jinja2 filters only
    end
  end
end
```

### Schema Discovery

1. Check for `.crinkle/schema.json` in project root
2. Check for `schema` path in `.crinkle/config.yaml`
3. Fall back to built-in Jinja2 filters/tests only

## Lint Rules

### Unknown Filter/Test/Function

```jinja
{{ x | nonexistent }}
```
**Error:** Unknown filter 'nonexistent'

```jinja
{% if x is nonexistent %}
```
**Error:** Unknown test 'nonexistent'

### Wrong Argument Count

```jinja
{{ x | truncate(1, 2, 3) }}
```
**Error:** Filter 'truncate' takes at most 2 arguments, got 3

```jinja
{{ x | truncate() }}
```
**Error:** Filter 'truncate' requires argument 'length'

### Unknown Keyword Argument

```jinja
{{ x | money_format(curreny="EUR") }}
```
**Error:** Unknown kwarg 'curreny' for filter 'money_format'. Did you mean 'currency'?

The "did you mean?" suggestion uses Levenshtein distance to find similar kwarg names.

### Missing Required Argument

```jinja
{{ truncate(value) }}
```
**Error:** Function 'truncate' requires argument 'length'

### Type Mismatch (if type info available)

```jinja
{{ "hello" | money_format }}
```
**Warning:** Filter 'money_format' expects Number, got String

Type checking requires context type information from `Crinkle.render` captures.

### Deprecated Usage

```jinja
{{ x | old_filter }}
```
**Warning:** Filter 'old_filter' is deprecated

### Callable Validation

**Named method calls:**
```jinja
{{ formatter.price(100, curreny="EUR") }}
```
**Error:** Unknown kwarg 'curreny' for Formatter.price. Did you mean 'currency'?

```jinja
{{ formatter.unknown_method(100) }}
```
**Error:** Formatter has no method 'unknown_method'. Available: price, date

**Default call (if defined):**
```jinja
{{ formatter(x, unknown=1) }}
```
**Error:** Unknown kwarg 'unknown' for Formatter

**Default call (if NOT defined):**
```jinja
{{ date_helper(x) }}
```
**Error:** DateHelper is not directly callable. Use a method: format, parse

Callable validation requires linking the variable to its type via template context from schema.

## Implementation

```crystal
class Crinkle::Linter
  def check_filter_call(node : AST::FilterCall) : Array(Diagnostic)
    filter = @schema.filters[node.name]?

    # Unknown filter
    return [unknown_filter(node)] unless filter

    diagnostics = [] of Diagnostic

    # Check positional args
    if node.args.size > filter.max_positional_args
      diagnostics << too_many_args(node, filter)
    end

    # Check required args
    filter.required_params.each do |param|
      unless node.has_arg?(param.name)
        diagnostics << missing_required(node, param)
      end
    end

    # Check kwargs
    node.kwargs.each do |name, _|
      unless filter.has_param?(name)
        diagnostics << unknown_kwarg(node, name, filter)
      end
    end

    # Check deprecated
    if filter.deprecated?
      diagnostics << deprecated_filter(node, filter)
    end

    diagnostics
  end
end
```

### "Did You Mean?" Suggestions

```crystal
def suggest_kwarg(unknown : String, known : Array(String)) : String?
  known.min_by? { |k| levenshtein(unknown, k) }
       .try { |k| k if levenshtein(unknown, k) <= 2 }
end
```

## Lint Rules Summary

| Rule | Severity | Example |
|------|----------|---------|
| Unknown filter | ERROR | `{{ x \| nonexistent }}` |
| Unknown test | ERROR | `{% if x is nonexistent %}` |
| Unknown function | ERROR | `{{ nonexistent() }}` |
| Wrong arg count | ERROR | `{{ x \| truncate(1,2,3) }}` |
| Unknown kwarg | ERROR | `{{ x \| f(typo=1) }}` |
| Missing required | ERROR | `{{ truncate(x) }}` |
| Type mismatch | WARNING | `{{ "hi" \| money_format }}` |
| Deprecated | WARNING | `{{ x \| old_filter }}` |
| Callable not callable | ERROR | `{{ date_helper() }}` |
| Callable default args | ERROR | `{{ formatter() }}` |
| Callable default kwarg | ERROR | `{{ formatter(x, bad=1) }}` |
| Callable method | ERROR | `{{ formatter.unknown() }}` |
| Callable method kwarg | ERROR | `{{ formatter.price(x, bad=1) }}` |

## CLI Integration

```bash
# Lint with schema
$ crinkle lint --schema .crinkle/schema.json templates/

# Auto-discover schema
$ crinkle lint templates/

# Lint without schema (built-ins only)
$ crinkle lint --no-schema templates/
```

## Acceptance Criteria

- [ ] Schema loader implemented
- [ ] Unknown filter/test/function lint rule
- [ ] Wrong argument count lint rule
- [ ] Unknown kwarg lint rule with suggestions
- [ ] Missing required argument lint rule
- [ ] Type mismatch lint rule (warning)
- [ ] Deprecated usage lint rule
- [ ] Callable validation lint rules
- [ ] CLI `--schema` flag
- [ ] Schema auto-discovery

## Checklist

### Schema Loading
- [ ] Implement `Schema.from_json`
- [ ] Schema discovery logic
- [ ] Graceful handling of missing/invalid schema
- [ ] CLI `--schema` and `--no-schema` flags

### Lint Rules
- [ ] Unknown filter/test/function
- [ ] Wrong positional argument count
- [ ] Unknown keyword argument
- [ ] "Did you mean?" suggestions (Levenshtein)
- [ ] Missing required argument
- [ ] Type mismatch (when type info available)
- [ ] Deprecated usage warning
- [ ] Callable "not directly callable" check
- [ ] Callable default call validation (if defined)
- [ ] Callable kwarg validation
- [ ] Callable named method validation
- [ ] Unknown method detection with suggestions

### Diagnostics
- [ ] Clear error messages with context
- [ ] Span information for IDE integration
- [ ] Severity levels (error vs warning)
- [ ] Machine-readable output format (JSON)

## Dependencies

- **Phase 22**: Schema generation (required)
